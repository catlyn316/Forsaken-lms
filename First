local update = "Roblox å…¨èƒ½æ§åˆ¶å™¨(ä¿®æ”¹ç‰ˆ v1.3 - forsakenå°ˆç”¨)å·²è¼‰å…¥"
local update2 = "æ›´æ–°ï¼šé˜²åç¹æœƒåµæ¸¬éšœç¤™ç‰© åµæ¸¬åˆ°æ™‚æš«åœè¿½è¹¤"

local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local PathfindingService = game:GetService("PathfindingService")
local TweenService = game:GetService("TweenService")

-- é˜²æ­¢é‡è¤‡åŸ·è¡Œ
if CoreGui:FindFirstChild("SpeedJumpController") then CoreGui.SpeedJumpController:Destroy() end
if playerGui:FindFirstChild("SpeedJumpController") then playerGui.SpeedJumpController:Destroy() end
if CoreGui:FindFirstChild("ShiftLockUI") then CoreGui.ShiftLockUI:Destroy() end
if playerGui:FindFirstChild("ShiftLockUI") then playerGui.ShiftLockUI:Destroy() end

-- ShiftLock ç³»çµ±è®Šæ•¸
local shiftLockEnabled = false
local shiftLockConnection = nil
local shiftLockUI = nil

-- ====================
-- æ ¸å¿ƒè®Šæ•¸èˆ‡å‚™ä»½
-- ====================

-- é–å®šæœ€åŸå§‹çš„å…‰ç…§è¨­å®š
local trueLightingBackup = {
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    Brightness = Lighting.Brightness,
    ColorShift_Bottom = Lighting.ColorShift_Bottom,
    ColorShift_Top = Lighting.ColorShift_Top,
    FogEnd = Lighting.FogEnd
}

-- åˆå§‹è§’è‰²æ•¸å€¼
local originalSpeed = 16
local hasOriginalValues = false

-- åŠŸèƒ½ç‹€æ…‹é–‹é—œ
local toggles = {
    speed = false,
    fullbright = false,
    cameraDist = false,
    nofog = false,
    noFilter = false,
    autoEvade = false,
    generatorESP = false,
    itemESP = false,
    autoInvisible = false,
    counterEvadeMode = "disguise"  -- "disguise" æˆ– "fullpower"
}

-- æ•¸å€¼è¨­å®š
local values = {
    speed = 34,
    fullbright = 1,
    cameraDist = 80,
    evadeRange = 15,
    evadeSpeed = 30
}

-- é€£ç·šå„²å­˜
local connections = {
    speed = nil,
    fullbright = nil,
    nofog = nil,
    noFilter = nil,
    autoEvade = nil,
    generatorESP = nil,
    itemESP = nil,
    autoInvisible = nil
}

-- ESP é¡¯ç¤ºç·©å­˜
local espObjects = {
    generators = {},
    items = {}
}

-- è‡ªå‹•åç¹ç³»çµ±è®Šæ•¸
local isEvading = false
local lastEvadeTime = 0
local evadeCooldown = 1.5

-- é˜²åç¹ç³»çµ±è®Šæ•¸
local isCounterEvading = false
local lastCounterEvadeTime = 0
local counterEvadeCooldown = 1
local lockedTarget = nil  -- ã€æ–°å¢ã€‘é–å®šçš„ç›®æ¨™
local targetLockStartTime = 0  -- ã€æ–°å¢ã€‘ç›®æ¨™é–å®šé–‹å§‹æ™‚é–“

-- ====================
-- ShiftLock ç³»çµ±
-- ====================

-- ç¦ç”¨ ShiftLock
local function disableShiftLock()
    if not shiftLockEnabled then return end
    
    shiftLockEnabled = false
    
    if shiftLockConnection then
        shiftLockConnection:Disconnect()
        shiftLockConnection = nil
    end
    
    -- æ¢å¾©æ»‘é¼ 
    if UserInputService.MouseEnabled then
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end
    
    -- æ¢å¾©è‡ªå‹•æ—‹è½‰
    local char = player.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.AutoRotate = true
        end
    end
end

-- å•Ÿç”¨ ShiftLock
local function enableShiftLock()
    if shiftLockEnabled then return end
    
    shiftLockEnabled = true
    
    -- é–å®šæ»‘é¼ 
    if UserInputService.MouseEnabled then
        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    end
    
    local char = player.Character
    if not char then return end
    
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hum or not hrp then return end
    
    hum.AutoRotate = false
    
    if shiftLockConnection then shiftLockConnection:Disconnect() end
    
    shiftLockConnection = RunService.RenderStepped:Connect(function()
        local myChar = player.Character
        if not myChar then return end
        
        local myHRP = myChar:FindFirstChild("HumanoidRootPart")
        if not myHRP then return end
        
        local cam = Workspace.CurrentCamera
        if not cam then return end
        
        local lookVector = cam.CFrame.LookVector
        local flatDir = Vector3.new(lookVector.X, 0, lookVector.Z)
        
        if flatDir.Magnitude > 0.001 then
            myHRP.CFrame = CFrame.lookAt(myHRP.Position, myHRP.Position + flatDir.Unit, Vector3.yAxis)
        end
    end)
end

-- ====================
-- æ ¸å¿ƒé‚è¼¯å‡½æ•¸
-- ====================

-- ç²å–åˆå§‹å€¼
local function getOriginalValues()
    if toggles.speed then return end
    
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            originalSpeed = humanoid.WalkSpeed
        end
    end
    hasOriginalValues = true
end

-- æ™ºèƒ½å…‰ç…§ç®¡ç†å™¨
local function updateLighting()
    if toggles.fullbright then
        if connections.fullbright then connections.fullbright:Disconnect() end
        
        connections.fullbright = RunService.RenderStepped:Connect(function()
            local ambientValue = math.min(values.fullbright, 99)
            Lighting.Ambient = Color3.new(ambientValue, ambientValue, ambientValue)
            Lighting.Brightness = values.fullbright
            Lighting.ColorShift_Bottom = Color3.new(ambientValue, ambientValue, ambientValue)
            Lighting.ColorShift_Top = Color3.new(ambientValue, ambientValue, ambientValue)
            Lighting.OutdoorAmbient = Color3.new(ambientValue, ambientValue, ambientValue)
        end)
    else
        if connections.fullbright then connections.fullbright:Disconnect() end
        
        Lighting.Ambient = trueLightingBackup.Ambient
        Lighting.Brightness = trueLightingBackup.Brightness
        Lighting.OutdoorAmbient = trueLightingBackup.OutdoorAmbient
        Lighting.ColorShift_Bottom = trueLightingBackup.ColorShift_Bottom
        Lighting.ColorShift_Top = trueLightingBackup.ColorShift_Top
    end
end

-- æ‡‰ç”¨é€Ÿåº¦
local function applySpeed(char)
    if not char then char = player.Character end
    if not char then return end
    local hum = char:WaitForChild("Humanoid", 10)
    if not hum then return end

    if connections.speed then connections.speed:Disconnect() end
    
    if toggles.speed then
        hum.WalkSpeed = values.speed
        connections.speed = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if toggles.speed then hum.WalkSpeed = values.speed end
        end)
    else
        hum.WalkSpeed = originalSpeed
    end
end

-- ====================
-- è‡ªå‹•åç¹ç³»çµ±
-- ====================

-- æª¢æŸ¥ç©å®¶æ˜¯å¦ç‚ºæ®ºæ‰‹
local function isPlayerKiller()
    -- èª¿è©¦è¼¸å‡º
    print("ğŸ” é–‹å§‹æª¢æ¸¬ç©å®¶èº«ä»½...")
    print("   ç•¶å‰ç©å®¶åç¨±ï¼š", player.Name)
    
    local playersFolder = Workspace:FindFirstChild("Players")
    if not playersFolder then 
        print("   âŒ æ‰¾ä¸åˆ° Workspace.Players")
        return false 
    end
    print("   âœ… æ‰¾åˆ° Workspace.Players")
    
    local killersFolder = playersFolder:FindFirstChild("Killers")
    if not killersFolder then 
        print("   âŒ æ‰¾ä¸åˆ° Workspace.Players.Killers")
        return false 
    end
    print("   âœ… æ‰¾åˆ° Workspace.Players.Killers")
    
    -- éæ­·æ‰€æœ‰æ®ºæ‰‹è§’è‰²
    print("   ğŸ” é–‹å§‹æª¢æŸ¥æ®ºæ‰‹åˆ—è¡¨...")
    for _, killerChar in pairs(killersFolder:GetChildren()) do
        if killerChar:IsA("Model") then
            print("      æª¢æŸ¥è§’è‰²ï¼š", killerChar.Name)
            
            -- æª¢æŸ¥ Attributes ä¸­çš„ Usernameï¼ˆå¤§å¯« Uï¼‰
            local username = killerChar:GetAttribute("Username")
            print("         Username å±¬æ€§å€¼ï¼š", username or "nil")
            
            if username then
                if username == player.Name then
                    print("   âœ…âœ…âœ… åŒ¹é…æˆåŠŸï¼ä½ æ˜¯æ®ºæ‰‹ï¼")
                    return true
                else
                    print("         ä¸åŒ¹é…ï¼ˆ", username, "â‰ ", player.Name, "ï¼‰")
                end
            else
                print("         è­¦å‘Šï¼šæ­¤è§’è‰²æ²’æœ‰ Username å±¬æ€§")
            end
        end
    end
    
    print("   âŒ æª¢æŸ¥å®Œç•¢ï¼Œä½ ä¸æ˜¯æ®ºæ‰‹")
    return false
end

-- å°‹æ‰¾æœ€è¿‘çš„æ®ºæ‰‹
local function findNearestKiller()
    local char = player.Character
    if not char then return nil, math.huge end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil, math.huge end
    
    local killersFolder = Workspace:FindFirstChild("Players")
    if not killersFolder then return nil, math.huge end
    killersFolder = killersFolder:FindFirstChild("Killers")
    if not killersFolder then return nil, math.huge end
    
    local nearestKiller = nil
    local minDistance = math.huge
    
    for _, killerChar in pairs(killersFolder:GetChildren()) do
        if killerChar:IsA("Model") then
            local killerHRP = killerChar:FindFirstChild("HumanoidRootPart")
            if killerHRP then
                local distance = (hrp.Position - killerHRP.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestKiller = killerChar
                end
            end
        end
    end
    
    return nearestKiller, minDistance
end

-- ==========================================================
-- ä¿®æ­£ç‰ˆæœ¬ï¼šä»¥æ®ºæ‰‹é¢å‘ç©å®¶çš„æ–¹å‘ç‚ºåŸºæº–
-- ==========================================================

-- åç¹è·¯å¾‘å®šç¾©
local EVADE_PATHS = {
    LEFT_BACK = 1,
    RIGHT_BACK = 2
}

-- è·¯å¾‘åƒæ•¸è¨ˆç®—ï¼ˆä»¥æ®ºæ‰‹è¦–è§’ç‚ºåŸºæº–ï¼‰
local function getPathParameters(mode, hrpPos, killerPos, radius)
    -- æ®ºæ‰‹æŒ‡å‘ç©å®¶çš„æ–¹å‘ï¼ˆæ®ºæ‰‹çš„"å‰æ–¹"ï¼‰
    local killerToPlayer = (hrpPos - killerPos).Unit
    -- æ®ºæ‰‹è¦–è§’çš„å·¦å³æ–¹å‘
    local killerPerpendicular = Vector3.new(-killerToPlayer.Z, 0, killerToPlayer.X)
    
    local startAngle, endAngle, centerPos
    
    if mode == EVADE_PATHS.LEFT_BACK then
        -- åœ“å¿ƒåœ¨ç©å®¶ä½ç½®ï¼Œå¾€æ®ºæ‰‹çš„å·¦å´åç§»
        centerPos = hrpPos + killerPerpendicular * radius
        -- å¾æ®ºæ‰‹æ–¹å‘é–‹å§‹ï¼Œé€†æ™‚é‡è½‰180åº¦åˆ°æ®ºæ‰‹å¾Œæ–¹
        startAngle = 0
        endAngle = math.pi
        
    elseif mode == EVADE_PATHS.RIGHT_BACK then
        -- åœ“å¿ƒåœ¨ç©å®¶ä½ç½®ï¼Œå¾€æ®ºæ‰‹çš„å³å´åç§»
        centerPos = hrpPos - killerPerpendicular * radius
        -- å¾æ®ºæ‰‹æ–¹å‘é–‹å§‹ï¼Œé †æ™‚é‡è½‰180åº¦åˆ°æ®ºæ‰‹å¾Œæ–¹
        startAngle = 0
        endAngle = -math.pi
    end
    
    return startAngle, endAngle, centerPos, killerToPlayer, killerPerpendicular
end

-- è·¯å¾‘è©•ä¼°
local function evaluatePath(mode, hrpPos, killerPos, radius, char)
    local startAngle, endAngle, centerPos, killerToPlayer, killerPerpendicular = getPathParameters(mode, hrpPos, killerPos, radius)
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char}
    
    local testPoints = 8
    local clearPoints = 0
    local minObstacleDistance = math.huge
    local hasBlockedPath = false
    
    for i = 0, testPoints do
        local t = i / testPoints
        local angle = startAngle + (endAngle - startAngle) * t
        
        -- è¨ˆç®—åœ“å‘¨ä¸Šçš„é»ï¼ˆç›¸å°æ–¼åœ“å¿ƒï¼‰
        -- angle=0æ™‚æŒ‡å‘æ®ºæ‰‹ï¼Œangle=Ï€æ™‚èƒŒå‘æ®ºæ‰‹
        local localForward = math.cos(angle) * radius  -- å‰å¾Œæ–¹å‘ï¼ˆæ®ºæ‰‹è¦–è§’ï¼‰
        local localSide = math.sin(angle) * radius     -- å·¦å³æ–¹å‘ï¼ˆæ®ºæ‰‹è¦–è§’ï¼‰
        
        -- è½‰æ›åˆ°ä¸–ç•Œåº§æ¨™
        local testPoint
        if mode == EVADE_PATHS.LEFT_BACK then
            -- å·¦å´ç¹è¡Œï¼šåœ“å¿ƒåœ¨å·¦å´ï¼Œå¾æ®ºæ‰‹æ–¹å‘é€†æ™‚é‡è½‰åˆ°å¾Œæ–¹
            testPoint = centerPos - killerToPlayer * localForward + killerPerpendicular * localSide
        else
            -- å³å´ç¹è¡Œï¼šåœ“å¿ƒåœ¨å³å´ï¼Œå¾æ®ºæ‰‹æ–¹å‘é †æ™‚é‡è½‰åˆ°å¾Œæ–¹
            testPoint = centerPos - killerToPlayer * localForward - killerPerpendicular * localSide
        end
        
        local ray = Workspace:Raycast(hrpPos, (testPoint - hrpPos), params)
        if not ray or (ray.Position - hrpPos).Magnitude > (testPoint - hrpPos).Magnitude * 0.9 then
            clearPoints = clearPoints + 1
        else
            local obstacleDistance = (ray.Position - testPoint).Magnitude
            minObstacleDistance = math.min(minObstacleDistance, obstacleDistance)
            
            if (ray.Position - hrpPos).Magnitude < (testPoint - hrpPos).Magnitude * 0.5 then
                hasBlockedPath = true
            end
        end
    end
    
    if hasBlockedPath then
        clearPoints = clearPoints * 0.3
    end
    
    local score = clearPoints * 10 + minObstacleDistance
    score = score + 100
    
    return score, clearPoints, hasBlockedPath, minObstacleDistance
end

-- è·¯å¾‘é¸æ“‡
local function chooseBestPath(hrpPos, killerPos, radius, char)
    local bestMode = EVADE_PATHS.LEFT_BACK
    local bestScore = -1
    local allPathsBlocked = true
    
    for mode = 1, 2 do
        local score, clearPoints, blocked, minObstacleDistance = evaluatePath(mode, hrpPos, killerPos, radius, char)
        if clearPoints > 4 then
            allPathsBlocked = false
        end
        
        if score > bestScore then
            bestScore = score
            bestMode = mode
        end
    end
    
    if allPathsBlocked then
        return nil
    end
    
    return bestMode
end

-- æ‡‰æ€¥é€ƒé›¢ç­–ç•¥
local function emergencyEvade(hrp, killerHRP, humanoid, char)
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
    bodyVelocity.P = 10000
    bodyVelocity.Parent = hrp
    
    humanoid.AutoRotate = false
    
    local toKillerDirection = (killerHRP.Position - hrp.Position).Unit
    local bestDirection = -toKillerDirection
    local maxScore = -math.huge
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char}
    
    for angle = 0, 2 * math.pi - 0.01, math.pi / 8 do
        local testDirection = Vector3.new(
            math.cos(angle),
            0,
            math.sin(angle)
        )
        
        local dotProduct = testDirection:Dot(toKillerDirection)
        
        if dotProduct > 0.5 then
            continue
        end
        
        local ray = Workspace:Raycast(hrp.Position, testDirection * values.evadeRange * 2, params)
        local clearDistance = ray and (ray.Position - hrp.Position).Magnitude or (values.evadeRange * 2)
        
        local score = clearDistance
        
        if dotProduct < -0.7 and dotProduct > -1 then
            score = score * 3
        elseif dotProduct <= -0.7 then
            score = score * 2
        elseif dotProduct < 0 then
            score = score * 1.5
        else
            score = score * 1.1
        end
        
        if score > maxScore then
            maxScore = score
            bestDirection = testDirection
        end
    end
    
    local rushTime = 1.5
    local rushSteps = math.ceil(rushTime / 0.03)
    
    for i = 1, rushSteps do
        if not isEvading or not toggles.autoEvade then break end
        
        bodyVelocity.Velocity = bestDirection * values.evadeSpeed * 1.2
        
        local lookDirection = bestDirection * Vector3.new(1, 0, 1)
        if lookDirection.Magnitude > 0 then
            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
        end
        
        task.wait(0.03)
    end
    
    bodyVelocity:Destroy()
    humanoid.AutoRotate = true
end

-- æª¢æ¸¬è·¯å¾‘æ˜¯å¦æœ‰éšœç¤™ç‰©
local function checkPathClear(startPos, endPos, char)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char}
    
    local direction = (endPos - startPos)
    local distance = direction.Magnitude
    
    if distance == 0 then return true end
    
    local ray = Workspace:Raycast(startPos, direction, params)
    return ray == nil or (ray.Position - startPos).Magnitude > distance * 0.9
end

-- å°‹æ‰¾æœ€ä½³åç¹åŠå¾‘
local function findBestEvadeRadius(startPos, killerPos, goLeft, char)
    local baseRadius = values.evadeRange
    local radiusOptions = {baseRadius, baseRadius * 0.75, baseRadius * 0.5, baseRadius * 1.25}
    
    for _, radius in ipairs(radiusOptions) do
        local killerToPlayer = (startPos - killerPos).Unit
        local killerPerpendicular = Vector3.new(-killerToPlayer.Z, 0, killerToPlayer.X)
        
        local testsPassed = true
        
        for angle = 0, math.pi, math.pi / 5 do
            local localForward = math.cos(angle) * radius
            local localSide = math.sin(angle) * radius
            
            local testPoint
            if goLeft then
                testPoint = (startPos + killerPerpendicular * radius) - killerToPlayer * localForward + killerPerpendicular * localSide
            else
                testPoint = (startPos - killerPerpendicular * radius) - killerToPlayer * localForward - killerPerpendicular * localSide
            end
            
            if not checkPathClear(startPos, testPoint, char) then
                testsPassed = false
                break
            end
        end
        
        if testsPassed then
            return radius
        end
    end
    
    return baseRadius * 0.5
end

-- åŸ·è¡Œåç¹å‹•ä½œ
local function performEvade()
    local char = player.Character
    if not char then return end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then return end
    
    local killer, distance = findNearestKiller()
    if not killer or distance > values.evadeRange then return end
    
    local killerHRP = killer:FindFirstChild("HumanoidRootPart")
    if not killerHRP then return end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char, killer}
    
    local directionToKiller = killerHRP.Position - hrp.Position
    local rayResult = Workspace:Raycast(hrp.Position, directionToKiller, params)
    
    if rayResult then
        return
    end
    
    local currentTime = tick()
    if currentTime - lastEvadeTime < evadeCooldown then return end
    
    isEvading = true
    lastEvadeTime = currentTime
    
    local originalWalkSpeed = humanoid.WalkSpeed
    local originalAutoRotate = humanoid.AutoRotate
    
    local evadeRadius = findBestEvadeRadius(hrp.Position, killerHRP.Position, true, char)
    
    local bestPathMode = chooseBestPath(hrp.Position, killerHRP.Position, evadeRadius, char)
    
    if not bestPathMode then
        disableShiftLock()
        
        task.spawn(function()
            emergencyEvade(hrp, killerHRP, humanoid, char)
            
            if toggles.speed then
                humanoid.WalkSpeed = values.speed
            else
                humanoid.WalkSpeed = originalSpeed
            end
            
            isEvading = false
        end)
        return
    end
    
    disableShiftLock()
    
    local startAngle, endAngle, centerPos, killerToPlayer, killerPerpendicular = getPathParameters(bestPathMode, hrp.Position, killerHRP.Position, evadeRadius)
    
    task.spawn(function()
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
        bodyVelocity.P = 10000
        bodyVelocity.Parent = hrp
        
        humanoid.AutoRotate = false
        
        local stuckCheckInterval = 0.15
        local lastCheckTime = tick()
        local lastPosition = hrp.Position
        local stuckThreshold = 1
        local consecutiveStuckCount = 0
        local maxStuckCount = 3
        
        local totalTime = (math.abs(endAngle - startAngle) * evadeRadius) / values.evadeSpeed
        local steps = math.ceil(totalTime / 0.03)
        local stepAngle = (endAngle - startAngle) / steps
        
        for i = 1, steps do
            if not isEvading or not toggles.autoEvade then break end
            
            local currentTime = tick()
            if currentTime - lastCheckTime >= stuckCheckInterval then
                local distanceMoved = (hrp.Position - lastPosition).Magnitude
                
                if distanceMoved < stuckThreshold then
                    consecutiveStuckCount = consecutiveStuckCount + 1
                    
                    if consecutiveStuckCount >= maxStuckCount then
                        local newBestMode = (bestPathMode == EVADE_PATHS.LEFT_BACK) and EVADE_PATHS.RIGHT_BACK or EVADE_PATHS.LEFT_BACK
                        
                        local score = evaluatePath(newBestMode, hrp.Position, killerHRP.Position, evadeRadius, char)
                        
                        if score > 0 then
                            bestPathMode = newBestMode
                            startAngle, endAngle, centerPos, killerToPlayer, killerPerpendicular = getPathParameters(bestPathMode, hrp.Position, killerHRP.Position, evadeRadius)
                            
                            local remainingAngle = math.abs(endAngle - startAngle)
                            steps = math.ceil((remainingAngle * evadeRadius / values.evadeSpeed) / 0.03)
                            stepAngle = (endAngle - startAngle) / steps
                            i = 0
                        else
                            evadeRadius = evadeRadius * 0.7
                            startAngle, endAngle, centerPos, killerToPlayer, killerPerpendicular = getPathParameters(bestPathMode, hrp.Position, killerHRP.Position, evadeRadius)
                            steps = math.ceil((math.abs(endAngle - startAngle) * evadeRadius / values.evadeSpeed) / 0.03)
                            stepAngle = (endAngle - startAngle) / steps
                            i = 0
                        end
                        
                        consecutiveStuckCount = 0
                    end
                else
                    consecutiveStuckCount = 0
                end
                
                lastPosition = hrp.Position
                lastCheckTime = currentTime
            end
            
            local angle = startAngle + stepAngle * i
            
            -- è¨ˆç®—åœ“å‘¨ä¸Šçš„é»ï¼ˆä»¥æ®ºæ‰‹è¦–è§’ç‚ºåŸºæº–ï¼‰
            local localForward = math.cos(angle) * evadeRadius
            local localSide = math.sin(angle) * evadeRadius
            
            -- è½‰æ›åˆ°ä¸–ç•Œåº§æ¨™
            local currentPoint
            if bestPathMode == EVADE_PATHS.LEFT_BACK then
                currentPoint = centerPos - killerToPlayer * localForward + killerPerpendicular * localSide
            else
                currentPoint = centerPos - killerToPlayer * localForward - killerPerpendicular * localSide
            end
            
            -- è¨ˆç®—ä¸‹ä¸€å€‹é»
            local nextAngle = startAngle + stepAngle * (i + 1)
            local nextLocalForward = math.cos(nextAngle) * evadeRadius
            local nextLocalSide = math.sin(nextAngle) * evadeRadius
            
            local nextPoint
            if bestPathMode == EVADE_PATHS.LEFT_BACK then
                nextPoint = centerPos - killerToPlayer * nextLocalForward + killerPerpendicular * nextLocalSide
            else
                nextPoint = centerPos - killerToPlayer * nextLocalForward - killerPerpendicular * nextLocalSide
            end
            
            -- è¨ˆç®—ç§»å‹•æ–¹å‘
            local moveDirection = (nextPoint - currentPoint).Unit
            bodyVelocity.Velocity = moveDirection * values.evadeSpeed
            
            -- é¢å‘ç§»å‹•æ–¹å‘
            local lookDirection = moveDirection * Vector3.new(1, 0, 1)
            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
            end
            
            task.wait(0.03)
        end
        
        -- åç¹å®Œæˆå¾Œç¹¼çºŒç›´èµ°ï¼ˆèƒŒé›¢æ®ºæ‰‹ï¼Œç›¸å°æ–¼æ®ºæ‰‹è¦–è§’çš„æ­£å¾Œæ–¹ï¼‰
        local finalDirection = -killerToPlayer
        local forwardDistance = evadeRadius
        local forwardTime = forwardDistance / values.evadeSpeed
        local forwardSteps = math.ceil(forwardTime / 0.03)
        
        for i = 1, forwardSteps do
            if not isEvading or not toggles.autoEvade then break end
            
            bodyVelocity.Velocity = finalDirection * values.evadeSpeed
            
            local lookDirection = finalDirection * Vector3.new(1, 0, 1)
            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
            end
            
            task.wait(0.03)
        end
        
        bodyVelocity:Destroy()
        humanoid.AutoRotate = originalAutoRotate
        
        if toggles.speed then
            humanoid.WalkSpeed = values.speed
        else
            humanoid.WalkSpeed = originalSpeed
        end
        
        isEvading = false
    end)
end



-- ==========================================================
-- ä¿®æ”¹ 7: å°‹æ‰¾æœ€è¿‘ç©å®¶å‡½æ•¸ï¼ˆæ”¯æ´é–å®šï¼‰
-- ==========================================================
local function findNearestPlayer()
    local char = player.Character
    if not char then return nil, math.huge end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil, math.huge end
    
    -- å¦‚æœæœ‰é–å®šçš„ç›®æ¨™ï¼Œä¸”é–å®šæ™‚é–“æœªè¶…é 3 ç§’ï¼Œç¹¼çºŒè¿½æ“Šè©²ç›®æ¨™
    local currentTime = tick()
    if lockedTarget and (currentTime - targetLockStartTime) < 3 then
        if lockedTarget.Character then
            local targetHRP = lockedTarget.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                local distance = (hrp.Position - targetHRP.Position).Magnitude
                print("ğŸ¯ ç¹¼çºŒé–å®šç›®æ¨™ï¼š", lockedTarget.Name, "å‰©é¤˜æ™‚é–“ï¼š", string.format("%.1f", 3 - (currentTime - targetLockStartTime)))
                return lockedTarget, distance
            end
        end
    end
    
    -- å¦‚æœæ²’æœ‰é–å®šç›®æ¨™ï¼Œæˆ–é–å®šæ™‚é–“å·²éï¼Œå°‹æ‰¾æ–°çš„æœ€è¿‘ç©å®¶
    local nearestPlayer = nil
    local minDistance = math.huge
    
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHRP then
                local distance = (hrp.Position - otherHRP.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    -- å¦‚æœæ‰¾åˆ°æ–°ç›®æ¨™ï¼Œé–å®šå®ƒ
    if nearestPlayer then
        lockedTarget = nearestPlayer
        targetLockStartTime = currentTime
        print("ğŸ”’ é–å®šæ–°ç›®æ¨™ï¼š", nearestPlayer.Name)
    end
    
    return nearestPlayer, minDistance
end

-- ====================
-- é˜²åç¹ç³»çµ±ï¼ˆæ®ºæ‰‹æ¨¡å¼ï¼‰
-- ====================

-- åŸ·è¡Œé˜²åç¹å‹•ä½œï¼ˆæ®ºæ‰‹è¿½æ“Šç©å®¶ï¼‰
local function performCounterEvade()
    print("ğŸ”ª [é˜²åç¹] é–‹å§‹åŸ·è¡Œæ®ºæ‰‹è¿½æ“Š...")
    print("   æ¨¡å¼ï¼š", toggles.counterEvadeMode == "disguise" and "å½è£æ¨¡å¼" or "å…¨é–‹æ¨¡å¼")
    
    local char = player.Character
    if not char then 
        print("âŒ [é˜²åç¹] æ‰¾ä¸åˆ°è§’è‰²")
        return 
    end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then 
        print("âŒ [é˜²åç¹] æ‰¾ä¸åˆ° HRP æˆ– Humanoid")
        return 
    end
    
    local targetPlayer, distance = findNearestPlayer()
    if not targetPlayer then 
        print("âŒ [é˜²åç¹] æ‰¾ä¸åˆ°ç›®æ¨™ç©å®¶")
        return 
    end
    if distance > values.evadeRange then 
        print("âŒ [é˜²åç¹] ç›®æ¨™è·é›¢éé ï¼š", distance, "> ", values.evadeRange)
        return 
    end
    
    print("âœ… [é˜²åç¹] æ‰¾åˆ°ç›®æ¨™ï¼š", targetPlayer.Name, "è·é›¢ï¼š", distance)
    
    -- ã€æ–°å¢ã€‘æª¢æŸ¥æ˜¯å¦æœ‰éšœç¤™ç‰©é˜»æ“‹
    local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then
        print("âŒ [é˜²åç¹] æ‰¾ä¸åˆ°ç›®æ¨™çš„ HRP")
        return
    end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char, targetPlayer.Character}
    
    local directionToTarget = targetHRP.Position - hrp.Position
    local rayResult = Workspace:Raycast(hrp.Position, directionToTarget, params)
    
    if rayResult then
        print("âš ï¸ [é˜²åç¹] æª¢æ¸¬åˆ°éšœç¤™ç‰©é˜»æ“‹ï¼Œæš«åœè¿½æ“Šï¼ˆä¸é€²å†·å»ï¼‰")
        return  -- ç›´æ¥è¿”å›ï¼Œä¸æ›´æ–° lastCounterEvadeTimeï¼Œä¸é€²å…¥å†·å»
    end
    
    print("âœ… [é˜²åç¹] è·¯å¾‘æš¢é€šï¼Œé–‹å§‹è¿½æ“Š")
    
    -- æª¢æŸ¥å†·å»æ™‚é–“
    -- å½è£æ¨¡å¼ï¼š1ç§’å†·å»
    -- å…¨é–‹æ¨¡å¼ï¼šç„¡å†·å»
    local currentTime = tick()
    if toggles.counterEvadeMode == "disguise" then
        if currentTime - lastCounterEvadeTime < 5 then 
            print("â±ï¸ [å½è£æ¨¡å¼] å†·å»ä¸­...")
            return 
        end
    end
    -- å…¨é–‹æ¨¡å¼ä¸æª¢æŸ¥å†·å»
    
    isCounterEvading = true
    lastCounterEvadeTime = currentTime
    
    print("ğŸƒ [é˜²åç¹] é–‹å§‹è¿½æ“Šï¼")
    
    -- è§£é™¤ ShiftLock
    disableShiftLock()
    
    -- ä¿å­˜åŸå§‹é€Ÿåº¦
    local originalWalkSpeed = humanoid.WalkSpeed
    local wasSpeedActive = toggles.speed
    
    -- å¦‚æœé€Ÿåº¦åŠŸèƒ½é–‹å•Ÿï¼Œå…ˆé—œé–‰å®ƒ
    if toggles.speed then
        toggles.speed = false
        if connections.speed then connections.speed:Disconnect() end
        humanoid.WalkSpeed = originalSpeed
    end
    
    task.spawn(function()
        local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then
            print("âŒ [é˜²åç¹] æ‰¾ä¸åˆ°ç›®æ¨™çš„ HRP")
            isCounterEvading = false
            return
        end
        
        -- ä½¿ç”¨ BodyVelocity æ§åˆ¶ç§»å‹•
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
        bodyVelocity.P = 10000
        bodyVelocity.Parent = hrp
        
        humanoid.AutoRotate = false
        
        print("âš¡ [é˜²åç¹] BodyVelocity å·²å‰µå»ºï¼Œé–‹å§‹ç§»å‹•ï¼ˆé€Ÿåº¦ï¼š", values.evadeSpeed, "ï¼‰")
        
        -- åœ¨ 1 ç§’å…§æŒçºŒç§»å‹•åˆ°ç›®æ¨™
        -- local duration = 1
        local duration = toggles.counterEvadeMode == "disguise" and 3 or 1
        local steps = math.ceil(duration / 0.03)

        -- å½è£æ¨¡å¼:ç›£æ§é€Ÿåº¦æ˜¯å¦è¢«è¨­ç‚ºå°æ–¼5
        local isDisguiseMode = toggles.counterEvadeMode == "disguise"
        
        for i = 1, steps do
            if not isCounterEvading or not toggles.autoEvade then
                print("âš ï¸ [é˜²åç¹] æå‰ä¸­æ–·")
                break
            end
            
            -- å½è£æ¨¡å¼:æª¢æŸ¥é€Ÿåº¦æ˜¯å¦å°æ–¼5
            if isDisguiseMode and humanoid.WalkSpeed < 5 then
                print("âš ï¸ [å½è£æ¨¡å¼] æª¢æ¸¬åˆ°é€Ÿåº¦å°æ–¼ 5,é€²å…¥å†·å»")
                lastCounterEvadeTime = tick()  -- ç«‹å³é€²å…¥å†·å»(5ç§’)
                break
            end

            -- ==========================================================
            -- ä¿®æ”¹ 8: é˜²åç¹è¿½æ“Šå‡½æ•¸ï¼ˆæŒçºŒè¿½æ“Šé–å®šçš„ç›®æ¨™ï¼Œä¸æ›´æ–°ç›®æ¨™ï¼‰
            -- ==========================================================
            if lockedTarget and lockedTarget.Character then
                targetHRP = lockedTarget.Character:FindFirstChild("HumanoidRootPart")
            end
            
            if not targetHRP then 
                print("âŒ [é˜²åç¹] ç›®æ¨™æ¶ˆå¤±")
                break 
            end
            
            -- è¨ˆç®—æ–¹å‘
            local direction = (targetHRP.Position - hrp.Position).Unit
            bodyVelocity.Velocity = direction * values.evadeSpeed
            
            -- é¢å‘ç›®æ¨™
            local lookDirection = direction * Vector3.new(1, 0, 1)
            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
            end
            
            task.wait(0.03)
        end
        
        print("âœ… [é˜²åç¹] è¿½æ“Šå®Œæˆï¼")
        
        -- æ¸…ç†
        bodyVelocity:Destroy()
        humanoid.AutoRotate = true
        
        -- æ¢å¾©é€Ÿåº¦è¨­ç½®
        if wasSpeedActive then
            toggles.speed = true
            applySpeed()
        else
            humanoid.WalkSpeed = originalSpeed
        end
        
        -- å•Ÿç”¨ ShiftLock
        task.wait(0.1)
        enableShiftLock()
        
        isCounterEvading = false
    end)
end

-- è‡ªå‹•åç¹ç›£æ§
local function startAutoEvade()
    if connections.autoEvade then connections.autoEvade:Disconnect() end
    
    if toggles.autoEvade then
        -- ç·©å­˜èº«ä»½æª¢æ¸¬çµæœï¼Œæ¯2ç§’æ›´æ–°ä¸€æ¬¡
        local cachedIsKiller = false
        local lastIdentityCheck = 0
        
        connections.autoEvade = RunService.Heartbeat:Connect(function()
            -- æ¯2ç§’æ›´æ–°ä¸€æ¬¡èº«ä»½
            local currentTime = tick()
            if currentTime - lastIdentityCheck > 2 then
                cachedIsKiller = isPlayerKiller()
                lastIdentityCheck = currentTime
            end
            
            if not isEvading and not isCounterEvading then
                if cachedIsKiller then
                    performCounterEvade()
                else
                    performEvade()
                end
            end
        end)
    else
        if connections.autoEvade then
            connections.autoEvade:Disconnect()
            connections.autoEvade = nil
        end
    end
end


-- ====================
-- ESP é¡¯ç¤ºç³»çµ±
-- ====================

-- å‰µå»º ESP é«˜äº®æ¡†
local function createESPBox(part, color, itemType)
    -- å‰µå»º BoxHandleAdornment
    local box = Instance.new("BoxHandleAdornment")
    box.Name = "ESPBox"
    box.Adornee = part
    box.Size = part.Size
    box.Color3 = color
    box.AlwaysOnTop = true
    box.ZIndex = 10
    box.Transparency = 0.7
    box.Parent = part
    
    -- å‰µå»º BillboardGui é¡¯ç¤ºè·é›¢å’Œé€²åº¦
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPLabel"
    billboard.Adornee = part
    billboard.Size = UDim2.new(0, 100, 0, 60)  -- å¢åŠ é«˜åº¦ä»¥å®¹ç´é€²åº¦
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = part
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.5
    label.TextSize = 14
    label.Font = Enum.Font.GothamBold
    label.Parent = billboard
    
    -- æ›´æ–°è·é›¢å’Œé€²åº¦é¡¯ç¤º
    local updateConnection
    updateConnection = RunService.RenderStepped:Connect(function()
        if not part or not part.Parent then
            updateConnection:Disconnect()
            return
        end
        
        local char = player.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local distance = (part.Position - hrp.Position).Magnitude
                
                -- å¦‚æœæ˜¯ç™¼é›»æ©Ÿï¼Œé¡¯ç¤ºé€²åº¦
                if itemType == "generator" then
                    local mainParent = part.Parent
                    local progress = mainParent and mainParent:FindFirstChild("Progress")
                    local progressValue = progress and progress.Value or 0
                    label.Text = string.format("%.1fm\né€²åº¦: %.1f%%", distance, progressValue)
                else
                    label.Text = string.format("%.1fm", distance)
                end
            end
        end
    end)
    
    return box, billboard, updateConnection
end

-- æ¸…é™¤æŒ‡å®šé¡å‹çš„ ESP
local function clearESP(espType)
    for _, espData in pairs(espObjects[espType]) do
        if espData.box then espData.box:Destroy() end
        if espData.billboard then espData.billboard:Destroy() end
        if espData.connection then espData.connection:Disconnect() end
    end
    espObjects[espType] = {}
end

-- æª¢æŸ¥ç‰©å“è·¯å¾‘æ˜¯å¦åŒ…å« itemrootï¼ˆä¸å€åˆ†å¤§å°å¯«ï¼‰
local function isItemInPath(obj)
    local current = obj
    while current do
        if current.Name:lower() == "itemroot" then
            return true
        end
        current = current.Parent
    end
    return false
end

-- æª¢æŸ¥ç™¼é›»æ©Ÿæ˜¯å¦ç¬¦åˆæ¢ä»¶ï¼ˆè·¯å¾‘åŒ…å«Mainä¸”æœ‰Promptï¼Œä½†æ’é™¤FakeGeneratorï¼‰
local function isValidGenerator(obj)
    -- æª¢æŸ¥è·¯å¾‘æ˜¯å¦åŒ…å« Main
    local hasMain = false
    local mainObject = nil
    local current = obj
    while current do
        if current.Name == "Main" then
            hasMain = true
            mainObject = current
            break
        end
        current = current.Parent
    end
    
    if not hasMain or not mainObject then return false end
    
    -- æª¢æŸ¥ Main çš„ Parent æ˜¯å¦ç‚º FakeGeneratorï¼ˆæ’é™¤å‡ç™¼é›»æ©Ÿï¼‰
    if mainObject.Parent and mainObject.Parent.Name == "FakeGenerator" then
        return false
    end
    
    -- æª¢æŸ¥æ˜¯å¦æœ‰ Prompt
    local hasPrompt = false
    for _, child in pairs(obj:GetDescendants()) do
        if child:IsA("ProximityPrompt") then
            hasPrompt = true
            break
        end
    end
    
    return hasPrompt
end

-- ç™¼é›»æ©Ÿ ESP
local function updateGeneratorESP()
    clearESP("generators")
    
    if not toggles.generatorESP then return end
    
    -- éæ­·æ•´å€‹ Workspaceï¼Œå°‹æ‰¾ç¬¦åˆæ¢ä»¶çš„ç™¼é›»æ©Ÿ
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and isValidGenerator(obj) then
            local box, billboard, connection = createESPBox(obj, Color3.fromRGB(0, 255, 0), "generator")  -- æ·»åŠ  "generator" åƒæ•¸
            table.insert(espObjects.generators, {
                part = obj,
                box = box,
                billboard = billboard,
                connection = connection
            })
        end
    end
end

-- ç‰©å“ ESP
local function updateItemESP()
    clearESP("items")
    
    if not toggles.itemESP then return end
    
    -- éæ­·æ•´å€‹ Workspaceï¼Œå°‹æ‰¾è·¯å¾‘åŒ…å« itemroot çš„ç‰©å“
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and isItemInPath(obj) then
            local box, billboard, connection = createESPBox(obj, Color3.fromRGB(255, 255, 0), "item")  -- æ·»åŠ  "item" åƒæ•¸
            table.insert(espObjects.items, {
                part = obj,
                box = box,
                billboard = billboard,
                connection = connection
            })
        end
    end
end

-- ç›£æ§æ–°ç”Ÿæˆçš„ç‰©å“å’Œç™¼é›»æ©Ÿ
local function startItemMonitoring()
    if connections.itemESP then connections.itemESP:Disconnect() end
    
    if toggles.itemESP then
        connections.itemESP = Workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("BasePart") and isItemInPath(descendant) then
                task.wait(0.1)
                if toggles.itemESP then
                    local box, billboard, connection = createESPBox(descendant, Color3.fromRGB(255, 255, 0), "item")  -- æ·»åŠ  "item" åƒæ•¸
                    table.insert(espObjects.items, {
                        part = descendant,
                        box = box,
                        billboard = billboard,
                        connection = connection
                    })
                end
            end
        end)
    end
end

-- ç›£æ§æ–°ç”Ÿæˆçš„ç™¼é›»æ©Ÿ
local function startGeneratorMonitoring()
    if connections.generatorESP then connections.generatorESP:Disconnect() end
    
    if toggles.generatorESP then
        connections.generatorESP = Workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("BasePart") then
                task.wait(0.1)  -- ç­‰å¾…å®Œå…¨åŠ è¼‰
                if toggles.generatorESP and isValidGenerator(descendant) then
                    local box, billboard, connection = createESPBox(descendant, Color3.fromRGB(0, 255, 0), "generator")  -- æ·»åŠ  "generator" åƒæ•¸
                    table.insert(espObjects.generators, {
                        part = descendant,
                        box = box,
                        billboard = billboard,
                        connection = connection
                    })
                end
            end
        end)
    end
end

-- é‡ç”Ÿç›£è½
player.CharacterAdded:Connect(function(newChar)
    task.wait(0.5)
    if toggles.speed then applySpeed(newChar) end
    lastEvadeTime = 0
    isEvading = false
end)

-- ====================
-- UI å»ºæ§‹
-- ====================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SpeedJumpController"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
screenGui.DisplayOrder = 10001

local function parentUI(g)
    local success = pcall(function()
        if gethui then g.Parent = gethui()
        elseif CoreGui then g.Parent = CoreGui
        else g.Parent = playerGui end
    end)
    if not success then g.Parent = playerGui end
end
parentUI(screenGui)

-- ä¸»è¦–çª—
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 260, 0, 262)
mainFrame.Position = UDim2.new(0.5, -130, 0.5, -131)
mainFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 10)

-- æ¨™é¡Œæ¬„
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 32)
titleBar.BackgroundColor3 = Color3.fromRGB(102, 126, 234)
titleBar.Parent = mainFrame
Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 10)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -60, 1, 0)
title.BackgroundTransparency = 1
title.Text = "è²“ç²çš„forsakenæ§åˆ¶å™¨"
title.TextSize = 14
title.Font = Enum.Font.GothamBold
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Parent = titleBar

local minimizeButton = Instance.new("TextButton")
minimizeButton.Size = UDim2.new(0, 24, 0, 24)
minimizeButton.Position = UDim2.new(1, -54, 0, 4)
minimizeButton.BackgroundColor3 = Color3.fromRGB(158, 158, 158)
minimizeButton.Text = "â”€"
minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeButton.Parent = titleBar
Instance.new("UICorner", minimizeButton).CornerRadius = UDim.new(0, 5)

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 24, 0, 24)
closeButton.Position = UDim2.new(1, -28, 0, 4)
closeButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Parent = titleBar
Instance.new("UICorner", closeButton).CornerRadius = UDim.new(0, 5)

-- åˆ†é ç³»çµ±
local tabBar = Instance.new("Frame")
tabBar.Size = UDim2.new(0.9, 0, 0, 28)
tabBar.Position = UDim2.new(0.05, 0, 0, 38)
tabBar.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
tabBar.Parent = mainFrame
Instance.new("UICorner", tabBar).CornerRadius = UDim.new(0, 6)

local function createTab(text, index)
    local tab = Instance.new("TextButton")
    tab.Size = UDim2.new(0.33, -4, 1, -4)
    tab.Position = UDim2.new((index-1) * 0.33, 2, 0, 2)
    tab.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
    tab.Text = text
    tab.TextSize = 12
    tab.Font = Enum.Font.GothamBold
    tab.TextColor3 = Color3.fromRGB(100, 100, 100)
    tab.Parent = tabBar
    Instance.new("UICorner", tab).CornerRadius = UDim.new(0, 4)
    return tab
end

local tab1 = createTab("åŸºæœ¬è¨­ç½®", 1)
local tab2 = createTab("è‡ªå‹•åç¹", 2)
local tab3 = createTab("å…¶ä»–", 3)

local contentContainer = Instance.new("Frame")
contentContainer.Size = UDim2.new(0.9, 0, 0, 150) 
contentContainer.Position = UDim2.new(0.05, 0, 0, 72)
contentContainer.BackgroundTransparency = 1
contentContainer.Parent = mainFrame
contentContainer.ClipsDescendants = true 

local function createScrollingPage(parent)
    local page = Instance.new("ScrollingFrame")
    page.Size = UDim2.new(1, 0, 1, 0)
    page.BackgroundTransparency = 1
    page.BorderSizePixel = 0
    page.ScrollBarThickness = 4
    page.AutomaticCanvasSize = Enum.AutomaticSize.Y
    page.Visible = false
    page.Parent = parent
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 6)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    layout.Parent = page
    local padding = Instance.new("UIPadding")
    padding.PaddingRight = UDim.new(0, 6)
    padding.Parent = page
    return page
end

local page1 = createScrollingPage(contentContainer)
local page2 = createScrollingPage(contentContainer)
local page3 = createScrollingPage(contentContainer)
page1.Visible = true

local function switchTab(pageNum)
    page1.Visible = (pageNum == 1)
    page2.Visible = (pageNum == 2)
    page3.Visible = (pageNum == 3)
    tab1.BackgroundColor3 = (pageNum == 1) and Color3.fromRGB(102, 126, 234) or Color3.fromRGB(200, 200, 200)
    tab1.TextColor3 = (pageNum == 1) and Color3.new(1,1,1) or Color3.fromRGB(100,100,100)
    tab2.BackgroundColor3 = (pageNum == 2) and Color3.fromRGB(102, 126, 234) or Color3.fromRGB(200, 200, 200)
    tab2.TextColor3 = (pageNum == 2) and Color3.new(1,1,1) or Color3.fromRGB(100,100,100)
    tab3.BackgroundColor3 = (pageNum == 3) and Color3.fromRGB(102, 126, 234) or Color3.fromRGB(200, 200, 200)
    tab3.TextColor3 = (pageNum == 3) and Color3.new(1,1,1) or Color3.fromRGB(100,100,100)
end
tab1.MouseButton1Click:Connect(function() switchTab(1) end)
tab2.MouseButton1Click:Connect(function() switchTab(2) end)
tab3.MouseButton1Click:Connect(function() switchTab(3) end)

-- é€šç”¨UIå‰µå»ºå‡½æ•¸
local function createControlRow(parent, labelText, placeholder, defaultVal, isInput, order)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 32)
    frame.BackgroundColor3 = Color3.fromRGB(248, 249, 250)
    frame.LayoutOrder = order or 0
    frame.Parent = parent
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 6)

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 75, 1, 0)
    label.Position = UDim2.new(0, 6, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextSize = 12
    label.Font = Enum.Font.GothamBold
    label.TextColor3 = Color3.fromRGB(85, 85, 85)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = frame

    local input
    if isInput then
        input = Instance.new("TextBox")
        input.Size = UDim2.new(0, 65, 0, 22)
        input.Position = UDim2.new(0, 80, 0, 5)
        input.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        input.BorderSizePixel = 1; input.BorderColor3 = Color3.fromRGB(221,221,221)
        input.Text = defaultVal
        input.PlaceholderText = placeholder
        input.TextSize = 13
        input.Font = Enum.Font.Gotham
        input.TextColor3 = Color3.fromRGB(50, 50, 50)
        input.Parent = frame
        Instance.new("UICorner", input).CornerRadius = UDim.new(0, 5)
    else
        input = Instance.new("TextLabel")
        input.Size = UDim2.new(0, 65, 0, 22)
        input.Position = UDim2.new(0, 80, 0, 5)
        input.BackgroundTransparency = 1
        input.Text = "é—œé–‰"
        input.TextSize = 13
        input.Font = Enum.Font.Gotham
        input.TextColor3 = Color3.fromRGB(150, 150, 150)
        input.Parent = frame
    end

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, 50, 0, 22)
    btn.Position = UDim2.new(1, -55, 0, 5)
    btn.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    btn.Text = "å•Ÿå‹•"
    btn.TextSize = 12
    btn.Font = Enum.Font.GothamBold
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Parent = frame
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 5)

    return frame, input, btn
end

-- å‰µå»ºç„¡æŒ‰éˆ•çš„è¼¸å…¥è¡Œï¼ˆç”¨æ–¼åç¹åƒæ•¸ï¼‰
local function createInputOnlyRow(parent, labelText, defaultVal, order)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 32)
    frame.BackgroundColor3 = Color3.fromRGB(248, 249, 250)
    frame.LayoutOrder = order or 0
    frame.Parent = parent
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 6)

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 120, 1, 0)
    label.Position = UDim2.new(0, 6, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextSize = 12
    label.Font = Enum.Font.GothamBold
    label.TextColor3 = Color3.fromRGB(85, 85, 85)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = frame

    local input = Instance.new("TextBox")
    input.Size = UDim2.new(0, 100, 0, 22)
    input.Position = UDim2.new(1, -105, 0, 5)
    input.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    input.BorderSizePixel = 1
    input.BorderColor3 = Color3.fromRGB(221, 221, 221)
    input.Text = defaultVal
    input.TextSize = 13
    input.Font = Enum.Font.Gotham
    input.TextColor3 = Color3.fromRGB(50, 50, 50)
    input.Parent = frame
    Instance.new("UICorner", input).CornerRadius = UDim.new(0, 5)

    return frame, input
end

-- é é¢ 1 - åŸºæœ¬è¨­ç½®
local speedFrame, speedInput, speedButton = createControlRow(page1, "é€Ÿåº¦:", "34", "34", true, 1)
local fullbrightFrame, fullbrightInput, fullbrightButton = createControlRow(page1, "å…¨äº®:", "1", "1", true, 2)
local cameraDistFrame, cameraDistInput, cameraDistButton = createControlRow(page1, "é¡é ­è·é›¢:", "80", "80", true, 3)
local nofogFrame, nofogStatus, nofogButton = createControlRow(page1, "é™¤éœ§:", "", "", false, 4)
local noFilterFrame, noFilterStatus, noFilterButton = createControlRow(page1, "ç„¡æ¿¾é¡:", "", "", false, 5)

-- é é¢ 2 - è‡ªå‹•åç¹
local evadeFrame, evadeStatus, evadeButton = createControlRow(page2, "åç¹/é˜²åç¹:", "", "", false, 1)
local evadeRangeFrame, evadeRangeInput = createInputOnlyRow(page2, "åç¹ç¯„åœ:", "15", 2)
local evadeSpeedFrame, evadeSpeedInput = createInputOnlyRow(page2, "åç¹é€Ÿåº¦:", "30", 3)

-- æ·»åŠ æ¨¡å¼æŒ‡ç¤ºæ¨™ç±¤
local evadeModeLabel = Instance.new("TextLabel")
evadeModeLabel.Size = UDim2.new(1, 0, 0, 20)
evadeModeLabel.Position = UDim2.new(0, 0, 0, 0)
evadeModeLabel.BackgroundTransparency = 1
evadeModeLabel.Text = "ç•¶å‰æ¨¡å¼ï¼šåç¹æ¨¡å¼"
evadeModeLabel.TextSize = 10
evadeModeLabel.Font = Enum.Font.GothamBold
evadeModeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
evadeModeLabel.LayoutOrder = 4
evadeModeLabel.Parent = page2

-- æ·»åŠ é˜²åç¹æ¨¡å¼é¸æ“‡ï¼ˆåƒ…æ®ºæ‰‹å¯è¦‹ï¼‰
local counterModeFrame = Instance.new("Frame")
counterModeFrame.Size = UDim2.new(1, 0, 0, 35)
counterModeFrame.BackgroundColor3 = Color3.fromRGB(248, 249, 250)
counterModeFrame.BorderSizePixel = 0
counterModeFrame.LayoutOrder = 5
counterModeFrame.Visible = false  -- é è¨­éš±è—
counterModeFrame.Parent = page2
Instance.new("UICorner", counterModeFrame).CornerRadius = UDim.new(0, 6)

local counterModeLabel = Instance.new("TextLabel")
counterModeLabel.Size = UDim2.new(0.35, 0, 1, 0)
counterModeLabel.Position = UDim2.new(0, 8, 0, 0)
counterModeLabel.BackgroundTransparency = 1
counterModeLabel.Text = "é˜²åç¹æ¨¡å¼:"
counterModeLabel.TextSize = 12
counterModeLabel.Font = Enum.Font.GothamMedium
counterModeLabel.TextColor3 = Color3.fromRGB(33, 33, 33)
counterModeLabel.TextXAlignment = Enum.TextXAlignment.Left
counterModeLabel.Parent = counterModeFrame

local counterModeButton = Instance.new("TextButton")
counterModeButton.Size = UDim2.new(0.3, 0, 0, 26)
counterModeButton.Position = UDim2.new(0.68, 0, 0.5, -13)
counterModeButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
counterModeButton.Text = "å½è£"
counterModeButton.TextSize = 11
counterModeButton.Font = Enum.Font.GothamBold
counterModeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
counterModeButton.Parent = counterModeFrame
Instance.new("UICorner", counterModeButton).CornerRadius = UDim.new(0, 5)

local counterModeStatus = Instance.new("TextLabel")
counterModeStatus.Size = UDim2.new(0.25, 0, 1, 0)
counterModeStatus.Position = UDim2.new(0.38, 0, 0, 0)
counterModeStatus.BackgroundTransparency = 1
counterModeStatus.Text = "å½è£"
counterModeStatus.TextSize = 11
counterModeStatus.Font = Enum.Font.GothamBold
counterModeStatus.TextColor3 = Color3.fromRGB(76, 175, 80)
counterModeStatus.Parent = counterModeFrame

-- é é¢ 3 - å…¶ä»–
local generatorESPFrame, generatorESPStatus, generatorESPButton = createControlRow(page3, "ç™¼é›»æ©Ÿé¡¯ç¤º:", "", "", false, 1)
local itemESPFrame, itemESPStatus, itemESPButton = createControlRow(page3, "ç‰©å“é¡¯ç¤º:", "", "", false, 2)
local autoInvisFrame, autoInvisStatus, autoInvisButton = createControlRow(page3, "éš±å½¢(å¯èƒ½æ‰è™›ç©º):", "", "", false, 3)

local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(0.9, 0, 0, 26)
statusLabel.Position = UDim2.new(0.05, 0, 1, -32)
statusLabel.BackgroundColor3 = Color3.fromRGB(255, 235, 238)
statusLabel.Text = "ç³»çµ±å°±ç·’"
statusLabel.TextSize = 11
statusLabel.Font = Enum.Font.GothamBold
statusLabel.TextColor3 = Color3.fromRGB(198, 40, 40)
statusLabel.Parent = mainFrame
Instance.new("UICorner", statusLabel).CornerRadius = UDim.new(0, 5)

-- ====================
-- åŠŸèƒ½å¯¦ä½œ
-- ====================

local function updateStatus()
    local active = {}
    if toggles.speed then table.insert(active, "é€Ÿåº¦") end
    if toggles.fullbright then table.insert(active, "å…¨äº®") end
    if toggles.autoEvade then table.insert(active, "åç¹") end
    
    if #active > 0 then
        statusLabel.Text = "âœ… " .. table.concat(active, " | ")
        statusLabel.BackgroundColor3 = Color3.fromRGB(232, 245, 233)
        statusLabel.TextColor3 = Color3.fromRGB(46, 125, 50)
    else
        statusLabel.Text = "ç³»çµ±å°±ç·’"
        statusLabel.BackgroundColor3 = Color3.fromRGB(255, 235, 238)
        statusLabel.TextColor3 = Color3.fromRGB(198, 40, 40)
    end
end

local function toggleUIState(btn, frame, input, isActive)
    if isActive then
        btn.Text = "è§£é™¤"; btn.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
        frame.BackgroundColor3 = Color3.fromRGB(227, 242, 253)
        if input and input:IsA("TextBox") then input.TextEditable = false end
    else
        btn.Text = "å•Ÿå‹•"; btn.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
        frame.BackgroundColor3 = Color3.fromRGB(248, 249, 250)
        if input and input:IsA("TextBox") then input.TextEditable = true end
    end
    updateStatus()
end

-- é€Ÿåº¦
speedButton.MouseButton1Click:Connect(function()
    toggles.speed = not toggles.speed
    if toggles.speed then
        if not hasOriginalValues then getOriginalValues() end
        values.speed = tonumber(speedInput.Text) or 34
        applySpeed()
    else
        applySpeed()
    end
    toggleUIState(speedButton, speedFrame, speedInput, toggles.speed)
end)

-- å…¨äº®
fullbrightButton.MouseButton1Click:Connect(function()
    toggles.fullbright = not toggles.fullbright
    if toggles.fullbright then
        local val = tonumber(fullbrightInput.Text) or 1
        values.fullbright = math.clamp(val, 0, 99)
        if val ~= values.fullbright then fullbrightInput.Text = tostring(values.fullbright) end
    end
    updateLighting()
    toggleUIState(fullbrightButton, fullbrightFrame, fullbrightInput, toggles.fullbright)
end)

-- ç„¡æ¿¾é¡
noFilterButton.MouseButton1Click:Connect(function()
    toggles.noFilter = not toggles.noFilter
    if toggles.noFilter then
        noFilterStatus.Text = "é–‹å•Ÿ"
        noFilterStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
        if connections.noFilter then connections.noFilter:Disconnect() end
        connections.noFilter = RunService.RenderStepped:Connect(function()
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("PostEffect") then v:Destroy() end
            end
            if Workspace.CurrentCamera then
                 for _, v in pairs(Workspace.CurrentCamera:GetChildren()) do
                    if v:IsA("PostEffect") then v:Destroy() end
                end
            end
        end)
    else
        noFilterStatus.Text = "é—œé–‰"
        noFilterStatus.TextColor3 = Color3.fromRGB(150, 150, 150)
        if connections.noFilter then connections.noFilter:Disconnect() end
    end
    toggleUIState(noFilterButton, noFilterFrame, noFilterStatus, toggles.noFilter)
end)

-- é™¤éœ§
nofogButton.MouseButton1Click:Connect(function()
    toggles.nofog = not toggles.nofog
    if toggles.nofog then
        nofogStatus.Text = "é–‹å•Ÿ"; nofogStatus.TextColor3 = Color3.fromRGB(46,125,50)
        if connections.nofog then connections.nofog:Disconnect() end
        connections.nofog = RunService.RenderStepped:Connect(function()
            Lighting.FogEnd = 100000
            for _, v in pairs(Lighting:GetDescendants()) do
                if v:IsA("Atmosphere") then v.Density = 0; v.Offset = 0 end
            end
        end)
    else
        nofogStatus.Text = "é—œé–‰"; nofogStatus.TextColor3 = Color3.fromRGB(150,150,150)
        if connections.nofog then connections.nofog:Disconnect() end
        Lighting.FogEnd = trueLightingBackup.FogEnd or 1000
    end
    toggleUIState(nofogButton, nofogFrame, nofogStatus, toggles.nofog)
end)

-- é¡é ­è·é›¢
cameraDistButton.MouseButton1Click:Connect(function()
    toggles.cameraDist = not toggles.cameraDist
    if toggles.cameraDist then
        values.cameraDist = tonumber(cameraDistInput.Text) or 80
        player.CameraMaxZoomDistance = values.cameraDist
        player.CameraMinZoomDistance = values.cameraDist
        if player.Character then
            local hum = player.Character:FindFirstChildOfClass("Humanoid")
            if hum then hum.CameraOffset = Vector3.new(0,0,0) end
        end
        task.delay(0.1, function()
            if toggles.cameraDist then player.CameraMinZoomDistance = 0.5 end
        end)
    else
        player.CameraMaxZoomDistance = 128
        player.CameraMinZoomDistance = 0.5
    end
    toggleUIState(cameraDistButton, cameraDistFrame, cameraDistInput, toggles.cameraDist)
end)

-- è‡ªå‹•åç¹/é˜²åç¹
evadeButton.MouseButton1Click:Connect(function()
    toggles.autoEvade = not toggles.autoEvade
    if toggles.autoEvade then
        values.evadeRange = tonumber(evadeRangeInput.Text) or 15
        values.evadeSpeed = tonumber(evadeSpeedInput.Text) or 30
        
        -- æª¢æ¸¬ä¸¦é¡¯ç¤ºç•¶å‰èº«ä»½
        local isKiller = isPlayerKiller()
        print("ğŸ” ç•¶å‰èº«ä»½æª¢æ¸¬ï¼š", isKiller and "æ®ºæ‰‹" or "å€–å­˜è€…")
        
        startAutoEvade()
        evadeStatus.Text = "é–‹å•Ÿ"
        evadeStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
        
        -- æ›´æ–°æ¨¡å¼é¡¯ç¤º
        if isKiller then
            evadeModeLabel.Text = "ç•¶å‰æ¨¡å¼ï¼šé˜²åç¹æ¨¡å¼ï¼ˆæ®ºæ‰‹ï¼‰"
            evadeModeLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            counterModeFrame.Visible = true  -- é¡¯ç¤ºæ¨¡å¼é¸æ“‡
        else
            evadeModeLabel.Text = "ç•¶å‰æ¨¡å¼ï¼šåç¹æ¨¡å¼ï¼ˆé€ƒç”Ÿè€…ï¼‰"
            evadeModeLabel.TextColor3 = Color3.fromRGB(100, 200, 100)
            counterModeFrame.Visible = false  -- éš±è—æ¨¡å¼é¸æ“‡
        end
    else
        if connections.autoEvade then connections.autoEvade:Disconnect() end
        evadeStatus.Text = "é—œé–‰"
        evadeStatus.TextColor3 = Color3.fromRGB(150, 150, 150)
        evadeModeLabel.Text = "ç•¶å‰æ¨¡å¼ï¼šæœªå•Ÿç”¨"
        evadeModeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        counterModeFrame.Visible = false  -- é—œé–‰æ™‚éš±è—
    end
    toggleUIState(evadeButton, evadeFrame, evadeStatus, toggles.autoEvade)
end)

-- é˜²åç¹æ¨¡å¼åˆ‡æ›æŒ‰éˆ•
counterModeButton.MouseButton1Click:Connect(function()
    if toggles.counterEvadeMode == "disguise" then
        toggles.counterEvadeMode = "fullpower"
        counterModeButton.Text = "å…¨é–‹"
        counterModeButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)  -- ç´…è‰²
        counterModeStatus.Text = "å…¨é–‹"
        counterModeStatus.TextColor3 = Color3.fromRGB(244, 67, 54)
        print("ğŸ”„ åˆ‡æ›åˆ°å…¨é–‹æ¨¡å¼")
    else
        toggles.counterEvadeMode = "disguise"
        counterModeButton.Text = "å½è£"
        counterModeButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)  -- ç¶ è‰²
        counterModeStatus.Text = "å½è£"
        counterModeStatus.TextColor3 = Color3.fromRGB(76, 175, 80)
        print("ğŸ”„ åˆ‡æ›åˆ°å½è£æ¨¡å¼")
    end
end)

-- å®šæœŸæ›´æ–°æ¨¡å¼é¡¯ç¤º
task.spawn(function()
    while true do
        task.wait(2)
        if toggles.autoEvade then
            local isKiller = isPlayerKiller()
            if isKiller then
                evadeModeLabel.Text = "ç•¶å‰æ¨¡å¼ï¼šé˜²åç¹æ¨¡å¼ï¼ˆæ®ºæ‰‹ï¼‰"
                evadeModeLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                counterModeFrame.Visible = true
            else
                evadeModeLabel.Text = "ç•¶å‰æ¨¡å¼ï¼šåç¹æ¨¡å¼ï¼ˆé€ƒç”Ÿè€…ï¼‰"
                evadeModeLabel.TextColor3 = Color3.fromRGB(100, 200, 100)
                counterModeFrame.Visible = false
            end
        end
    end
end)

-- æ›´æ–°åç¹åƒæ•¸
evadeRangeInput.FocusLost:Connect(function()
    values.evadeRange = tonumber(evadeRangeInput.Text) or 15
    evadeRangeInput.Text = tostring(values.evadeRange)
end)

evadeSpeedInput.FocusLost:Connect(function()
    values.evadeSpeed = tonumber(evadeSpeedInput.Text) or 30
    evadeSpeedInput.Text = tostring(values.evadeSpeed)
end)

-- ç™¼é›»æ©Ÿé¡¯ç¤º
generatorESPButton.MouseButton1Click:Connect(function()
    toggles.generatorESP = not toggles.generatorESP
    if toggles.generatorESP then
        generatorESPStatus.Text = "é–‹å•Ÿ"
        generatorESPStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
        updateGeneratorESP()
        startGeneratorMonitoring()
    else
        generatorESPStatus.Text = "é—œé–‰"
        generatorESPStatus.TextColor3 = Color3.fromRGB(150, 150, 150)
        clearESP("generators")
        if connections.generatorESP then connections.generatorESP:Disconnect() end
    end
    toggleUIState(generatorESPButton, generatorESPFrame, generatorESPStatus, toggles.generatorESP)
end)

-- ç‰©å“é¡¯ç¤º
itemESPButton.MouseButton1Click:Connect(function()
    toggles.itemESP = not toggles.itemESP
    if toggles.itemESP then
        itemESPStatus.Text = "é–‹å•Ÿ"
        itemESPStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
        updateItemESP()
        startItemMonitoring()
    else
        itemESPStatus.Text = "é—œé–‰"
        itemESPStatus.TextColor3 = Color3.fromRGB(150, 150, 150)
        clearESP("items")
        if connections.itemESP then connections.itemESP:Disconnect() end
    end
    toggleUIState(itemESPButton, itemESPFrame, itemESPStatus, toggles.itemESP)
end)

-- ====================
-- è‡ªå‹•éš±å½¢ç³»çµ±ï¼ˆåŸå§‹è…³æœ¬å®Œæ•´ç‰ˆï¼‰
-- ====================

-- è‡ªå‹•éš±å½¢å°ˆç”¨è®Šæ•¸ï¼ˆç¨ç«‹æ–¼ä¸»ç³»çµ±ï¼‰
local autoInvisToggles = {
    autoEvade = false
}

local autoInvisValues = {
    evadeRange = 15,
    evadeSpeed = 30
}

local autoInvisConnections = {
    autoEvade = nil
}

local isAutoInvisEvading = false
local lastAutoInvisEvadeTime = 0
local autoInvisEvadeCooldown = 1.5

-- å°‹æ‰¾æœ€è¿‘çš„ç©å®¶ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰
local function findNearestPlayerForInvis()
    local char = player.Character
    if not char then return nil, math.huge end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil, math.huge end
    
    local nearestPlayer = nil
    local minDistance = math.huge
    
    -- éæ­·æ‰€æœ‰ç©å®¶ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer.Character then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHRP then
                local distance = (hrp.Position - otherHRP.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer, minDistance
end

-- 4ç¨®åŠåœ“è·¯å¾‘æ¨¡å¼
local EVADE_PATHS = {
    LEFT_FORWARD = 1,
    LEFT_BACK = 2,
    RIGHT_FORWARD = 3,
    RIGHT_BACK = 4
}

-- è¨ˆç®—æŒ‡å®šè·¯å¾‘æ¨¡å¼çš„åŠåœ“åƒæ•¸
local function getPathParameters(mode, hrpPos, targetPos, radius)
    local directionToTarget = (targetPos - hrpPos).Unit
    local perpendicular = Vector3.new(-directionToTarget.Z, 0, directionToTarget.X)
    
    local startAngle, endAngle, centerPos
    
    if mode == EVADE_PATHS.LEFT_FORWARD then
        startAngle = 0
        endAngle = math.pi
        centerPos = hrpPos - directionToTarget * radius
        
    elseif mode == EVADE_PATHS.LEFT_BACK then
        startAngle = math.pi / 2
        endAngle = math.pi * 1.5
        centerPos = hrpPos + perpendicular * radius
        
    elseif mode == EVADE_PATHS.RIGHT_FORWARD then
        startAngle = math.pi
        endAngle = math.pi * 2
        centerPos = hrpPos - directionToTarget * radius
        
    elseif mode == EVADE_PATHS.RIGHT_BACK then
        startAngle = math.pi
        endAngle = math.pi * 2
        centerPos = hrpPos - perpendicular * radius
    end
    
    return startAngle, endAngle, centerPos
end

-- è©•ä¼°è·¯å¾‘çš„å®‰å…¨æ€§
local function evaluatePath(mode, hrpPos, targetPos, radius, char)
    local startAngle, endAngle, centerPos = getPathParameters(mode, hrpPos, targetPos, radius)
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char}
    
    local testPoints = 8
    local clearPoints = 0
    local totalDistance = 0
    local hasBlockedPath = false
    
    for i = 0, testPoints do
        local t = i / testPoints
        local angle = startAngle + (endAngle - startAngle) * t
        local offset = Vector3.new(
            math.cos(angle) * radius,
            0,
            math.sin(angle) * radius
        )
        local testPoint = centerPos + offset
        
        local ray = Workspace:Raycast(hrpPos, (testPoint - hrpPos), params)
        if not ray or (ray.Position - hrpPos).Magnitude > (testPoint - hrpPos).Magnitude * 0.9 then
            clearPoints = clearPoints + 1
        else
            if (ray.Position - hrpPos).Magnitude < (testPoint - hrpPos).Magnitude * 0.5 then
                hasBlockedPath = true
            end
        end
        
        if i == testPoints then
            totalDistance = (testPoint - targetPos).Magnitude
        end
    end
    
    if hasBlockedPath then
        clearPoints = clearPoints * 0.3
    end
    
    local score = clearPoints + (totalDistance / 10)
    
    -- å„ªå…ˆå¾€å¾Œæ–¹ç¹
    if mode == EVADE_PATHS.LEFT_BACK or mode == EVADE_PATHS.RIGHT_BACK then
        score = score + 100
    elseif mode == EVADE_PATHS.LEFT_FORWARD or mode == EVADE_PATHS.RIGHT_FORWARD then
        score = score + 20
    end
    
    return score, clearPoints, hasBlockedPath
end

-- é¸æ“‡æœ€ä½³é€ƒé›¢è·¯å¾‘
local function chooseBestPath(hrpPos, targetPos, radius, char)
    local bestMode = EVADE_PATHS.LEFT_FORWARD
    local bestScore = -1
    local allPathsBlocked = true
    
    for mode = 1, 4 do
        local score, clearPoints, blocked = evaluatePath(mode, hrpPos, targetPos, radius, char)
        if clearPoints > 4 then
            allPathsBlocked = false
        end
        
        if score > bestScore then
            bestScore = score
            bestMode = mode
        end
    end
    
    if allPathsBlocked then
        return nil
    end
    
    return bestMode
end

-- æ‡‰æ€¥é€ƒé›¢ç­–ç•¥
local function emergencyEvade(hrp, targetHRP, humanoid, char)
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
    bodyVelocity.P = 10000
    bodyVelocity.Parent = hrp
    
    humanoid.AutoRotate = false
    
    local toTargetDirection = (targetHRP.Position - hrp.Position).Unit
    local awayDirection = -toTargetDirection
    local bestDirection = awayDirection
    local maxScore = -math.huge
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char}
    
    for angle = 0, 2 * math.pi - 0.01, math.pi / 8 do
        local testDirection = Vector3.new(
            math.cos(angle),
            0,
            math.sin(angle)
        )
        
        local dotProduct = testDirection:Dot(toTargetDirection)
        
        if dotProduct > 0.5 then
            continue
        end
        
        local ray = Workspace:Raycast(hrp.Position, testDirection * autoInvisValues.evadeRange * 2, params)
        local clearDistance = ray and (ray.Position - hrp.Position).Magnitude or (autoInvisValues.evadeRange * 2)
        
        local score = clearDistance
        
        if dotProduct < -0.7 and dotProduct > -1 then
            score = score * 3
        elseif dotProduct <= -0.7 then
            score = score * 2
        elseif dotProduct < 0 then
            score = score * 1.5
        else
            score = score * 1.1
        end
        
        if score > maxScore then
            maxScore = score
            bestDirection = testDirection
        end
    end
    
    if maxScore <= 0 then
        bestDirection = awayDirection
    end
    
    local rushTime = 1.5
    local rushSteps = math.ceil(rushTime / 0.03)
    
    for i = 1, rushSteps do
        if not isAutoInvisEvading or not autoInvisToggles.autoEvade then break end
        
        bodyVelocity.Velocity = bestDirection * autoInvisValues.evadeSpeed * 1.2
        
        local lookDirection = bestDirection * Vector3.new(1, 0, 1)
        if lookDirection.Magnitude > 0 then
            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
        end
        
        task.wait(0.03)
    end
    
    bodyVelocity:Destroy()
    humanoid.AutoRotate = true
end

-- æª¢æ¸¬è·¯å¾‘æ˜¯å¦æš¢é€š
local function checkPathClear(startPos, endPos, char)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char}
    
    local direction = (endPos - startPos)
    local distance = direction.Magnitude
    
    if distance == 0 then return true end
    
    local ray = Workspace:Raycast(startPos, direction, params)
    return ray == nil or (ray.Position - startPos).Magnitude > distance * 0.9
end

-- å°‹æ‰¾æœ€ä½³åç¹åŠå¾‘
local function findBestEvadeRadius(startPos, targetPos, char)
    local baseRadius = autoInvisValues.evadeRange
    local radiusOptions = {baseRadius, baseRadius * 0.75, baseRadius * 0.5, baseRadius * 1.25}
    
    for _, radius in ipairs(radiusOptions) do
        local directionToTarget = (targetPos - startPos).Unit
        
        local testsPassed = true
        local startAngle = 0
        local endAngle = math.pi
        
        for testAngle = startAngle, endAngle, (endAngle - startAngle) / 5 do
            local offset = Vector3.new(
                math.cos(testAngle) * radius,
                0,
                math.sin(testAngle) * radius
            )
            local centerPos = startPos - directionToTarget * radius
            local testPoint = centerPos + offset
            
            if not checkPathClear(startPos, testPoint, char) then
                testsPassed = false
                break
            end
        end
        
        if testsPassed then
            return radius
        end
    end
    
    return baseRadius * 0.5
end

-- åŸ·è¡Œåç¹å‹•ä½œ
local function performAutoInvisEvade()
    local char = player.Character
    if not char then return end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then return end
    
    local targetPlayer, distance = findNearestPlayerForInvis()
    if not targetPlayer or distance > autoInvisValues.evadeRange then return end
    
    local targetChar = targetPlayer.Character
    if not targetChar then return end
    
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end
    
    -- æª¢æŸ¥æ˜¯å¦æœ‰éšœç¤™ç‰©é˜»æ“‹
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {char, targetChar}
    
    local directionToTarget = targetHRP.Position - hrp.Position
    local rayResult = Workspace:Raycast(hrp.Position, directionToTarget, params)
    
    if rayResult then
        return
    end
    
    -- æª¢æŸ¥å†·å»æ™‚é–“
    local currentTime = tick()
    if currentTime - lastAutoInvisEvadeTime < autoInvisEvadeCooldown then return end
    
    isAutoInvisEvading = true
    lastAutoInvisEvadeTime = currentTime
    
    local originalAutoRotate = humanoid.AutoRotate
    
    local evadeRadius = findBestEvadeRadius(hrp.Position, targetHRP.Position, char)
    local bestPathMode = chooseBestPath(hrp.Position, targetHRP.Position, evadeRadius, char)
    
    -- å¦‚æœæ‰€æœ‰è·¯å¾‘éƒ½è¢«é˜»æ“‹ï¼Œä½¿ç”¨æ‡‰æ€¥ç­–ç•¥
    if not bestPathMode then
        task.spawn(function()
            emergencyEvade(hrp, targetHRP, humanoid, char)
            isAutoInvisEvading = false
        end)
        return
    end
    
    local startAngle, endAngle, centerPos = getPathParameters(bestPathMode, hrp.Position, targetHRP.Position, evadeRadius)
    
    task.spawn(function()
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
        bodyVelocity.P = 10000
        bodyVelocity.Parent = hrp
        
        humanoid.AutoRotate = false
        
        -- æ’ç‰†æª¢æ¸¬è®Šæ•¸
        local stuckCheckInterval = 0.15
        local lastCheckTime = tick()
        local lastPosition = hrp.Position
        local stuckThreshold = 1
        local consecutiveStuckCount = 0
        local maxStuckCount = 3
        
        local totalTime = (math.pi * evadeRadius) / autoInvisValues.evadeSpeed
        local steps = math.ceil(totalTime / 0.03)
        local stepAngle = (endAngle - startAngle) / steps
        
        for i = 1, steps do
            if not isAutoInvisEvading or not autoInvisToggles.autoEvade then break end
            
            -- æª¢æ¸¬æ˜¯å¦å¡ä½
            local currentTime = tick()
            if currentTime - lastCheckTime >= stuckCheckInterval then
                local distanceMoved = (hrp.Position - lastPosition).Magnitude
                
                if distanceMoved < stuckThreshold then
                    consecutiveStuckCount = consecutiveStuckCount + 1
                    
                    if consecutiveStuckCount >= maxStuckCount then
                        -- åˆ‡æ›è·¯å¾‘
                        local excludePath = bestPathMode
                        local newBestMode = bestPathMode
                        local newBestScore = -999
                        
                        for mode = 1, 4 do
                            if mode ~= excludePath then
                                local score = evaluatePath(mode, hrp.Position, targetHRP.Position, evadeRadius, char)
                                if score > newBestScore then
                                    newBestScore = score
                                    newBestMode = mode
                                end
                            end
                        end
                        
                        if newBestMode ~= bestPathMode then
                            bestPathMode = newBestMode
                            startAngle, endAngle, centerPos = getPathParameters(bestPathMode, hrp.Position, targetHRP.Position, evadeRadius)
                            
                            local remainingAngle = endAngle - startAngle
                            steps = math.ceil((remainingAngle * evadeRadius / autoInvisValues.evadeSpeed) / 0.03)
                            stepAngle = remainingAngle / steps
                            i = 0
                        else
                            evadeRadius = evadeRadius * 0.7
                            startAngle, endAngle, centerPos = getPathParameters(bestPathMode, hrp.Position, targetHRP.Position, evadeRadius)
                            steps = math.ceil((math.pi * evadeRadius / autoInvisValues.evadeSpeed) / 0.03)
                            stepAngle = (endAngle - startAngle) / steps
                            i = 0
                        end
                        
                        consecutiveStuckCount = 0
                    end
                else
                    consecutiveStuckCount = 0
                end
                
                lastPosition = hrp.Position
                lastCheckTime = currentTime
            end
            
            local angle = startAngle + stepAngle * i
            local nextAngle = startAngle + stepAngle * (i + 1)
            
            local currentOffset = Vector3.new(
                math.cos(angle) * evadeRadius,
                0,
                math.sin(angle) * evadeRadius
            )
            local nextOffset = Vector3.new(
                math.cos(nextAngle) * evadeRadius,
                0,
                math.sin(nextAngle) * evadeRadius
            )
            
            local currentPoint = centerPos + currentOffset
            local nextPoint = centerPos + nextOffset
            
            local moveDirection = (nextPoint - currentPoint).Unit
            bodyVelocity.Velocity = moveDirection * autoInvisValues.evadeSpeed
            
            local lookDirection = moveDirection * Vector3.new(1, 0, 1)
            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
            end
            
            task.wait(0.03)
        end
        
        -- åç¹å®Œæˆå¾Œç¹¼çºŒå‰é€²
        local finalDirection = (hrp.Position - targetHRP.Position).Unit
        local forwardDistance = evadeRadius
        local forwardTime = forwardDistance / autoInvisValues.evadeSpeed
        local forwardSteps = math.ceil(forwardTime / 0.03)
        
        for i = 1, forwardSteps do
            if not isAutoInvisEvading or not autoInvisToggles.autoEvade then break end
            
            bodyVelocity.Velocity = finalDirection * autoInvisValues.evadeSpeed
            
            local lookDirection = finalDirection * Vector3.new(1, 0, 1)
            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirection)
            end
            
            task.wait(0.03)
        end
        
        bodyVelocity:Destroy()
        humanoid.AutoRotate = originalAutoRotate
        isAutoInvisEvading = false
    end)
end

-- è‡ªå‹•åç¹ç›£æ§
local function startAutoInvisible()
    if autoInvisConnections.autoEvade then autoInvisConnections.autoEvade:Disconnect() end
    
    if autoInvisToggles.autoEvade then
        autoInvisConnections.autoEvade = RunService.Heartbeat:Connect(function()
            if not isAutoInvisEvading then
                performAutoInvisEvade()
            end
        end)
    end
end

-- éš±å½¢æŒ‰éˆ•
autoInvisButton.MouseButton1Click:Connect(function()
    toggles.autoInvisible = not toggles.autoInvisible
    autoInvisToggles.autoEvade = toggles.autoInvisible
    
    if toggles.autoInvisible then
        startAutoInvisible()
        autoInvisStatus.Text = "é–‹å•Ÿ"
        autoInvisStatus.TextColor3 = Color3.fromRGB(138, 43, 226)
        print("ğŸ‘» è‡ªå‹•éš±å½¢å·²å•Ÿå‹•")
    else
        if autoInvisConnections.autoEvade then autoInvisConnections.autoEvade:Disconnect() end
        autoInvisStatus.Text = "é—œé–‰"
        autoInvisStatus.TextColor3 = Color3.fromRGB(150, 150, 150)
        print("ğŸ”† è‡ªå‹•éš±å½¢å·²é—œé–‰")
    end
    toggleUIState(autoInvisButton, autoInvisFrame, autoInvisStatus, toggles.autoInvisible)
end)

-- è‡ªå‹•å•Ÿç”¨åŠŸèƒ½
task.spawn(function()
    task.wait(1)
    
    -- è‡ªå‹•å•Ÿç”¨å…¨äº®
    toggles.fullbright = true
    updateLighting()
    toggleUIState(fullbrightButton, fullbrightFrame, fullbrightInput, true)
    
    -- è‡ªå‹•å•Ÿç”¨é¡é ­è·é›¢
    toggles.cameraDist = true
    player.CameraMaxZoomDistance = values.cameraDist
    player.CameraMinZoomDistance = values.cameraDist
    task.delay(0.1, function()
        if toggles.cameraDist then player.CameraMinZoomDistance = 0.5 end
    end)
    toggleUIState(cameraDistButton, cameraDistFrame, cameraDistInput, true)
    
    -- è‡ªå‹•å•Ÿç”¨é™¤éœ§
    toggles.nofog = true
    if connections.nofog then connections.nofog:Disconnect() end
    connections.nofog = RunService.RenderStepped:Connect(function()
        Lighting.FogEnd = 100000
        for _, v in pairs(Lighting:GetDescendants()) do
            if v:IsA("Atmosphere") then v.Density = 0; v.Offset = 0 end
        end
    end)
    nofogStatus.Text = "é–‹å•Ÿ"
    nofogStatus.TextColor3 = Color3.fromRGB(46,125,50)
    toggleUIState(nofogButton, nofogFrame, nofogStatus, true)
    
    -- è‡ªå‹•å•Ÿç”¨ç„¡æ¿¾é¡
    toggles.noFilter = true
    if connections.noFilter then connections.noFilter:Disconnect() end
    connections.noFilter = RunService.RenderStepped:Connect(function()
        for _, v in pairs(Lighting:GetChildren()) do
            if v:IsA("PostEffect") then v:Destroy() end
        end
        if Workspace.CurrentCamera then
             for _, v in pairs(Workspace.CurrentCamera:GetChildren()) do
                if v:IsA("PostEffect") then v:Destroy() end
            end
        end
    end)
    noFilterStatus.Text = "é–‹å•Ÿ"
    noFilterStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
    toggleUIState(noFilterButton, noFilterFrame, noFilterStatus, true)

    -- è‡ªå‹•å•Ÿç”¨ç™¼é›»æ©Ÿé¡¯ç¤º
    toggles.generatorESP = true
    generatorESPStatus.Text = "é–‹å•Ÿ"
    generatorESPStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
    updateGeneratorESP()
    startGeneratorMonitoring()
    toggleUIState(generatorESPButton, generatorESPFrame, generatorESPStatus, true)
    
    -- è‡ªå‹•å•Ÿç”¨ç‰©å“é¡¯ç¤º
    toggles.itemESP = true
    itemESPStatus.Text = "é–‹å•Ÿ"
    itemESPStatus.TextColor3 = Color3.fromRGB(46, 125, 50)
    updateItemESP()
    startItemMonitoring()
    toggleUIState(itemESPButton, itemESPFrame, itemESPStatus, true)
end)

-- æ‹–æ›³åŠŸèƒ½
local function enableDrag(frame, dragHandle)
    local dragging = false
    local dragInput, dragStart, startPos

    local function update(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    dragHandle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
end

enableDrag(mainFrame, titleBar)

-- æœ€å°åŒ–UI
local miniFrame = Instance.new("Frame"); miniFrame.Size=UDim2.new(0,130,0,32); miniFrame.Position=UDim2.new(0.5,-65,0,30); miniFrame.BackgroundColor3=Color3.fromRGB(102,126,234); miniFrame.Visible=false; miniFrame.Parent=screenGui; Instance.new("UICorner", miniFrame).CornerRadius=UDim.new(0,6)
local miniTitle = Instance.new("TextLabel"); miniTitle.Text="ğŸ® æ§åˆ¶å™¨"; miniTitle.Size=UDim2.new(1,-36,1,0); miniTitle.BackgroundTransparency=1; miniTitle.Font=Enum.Font.GothamBold; miniTitle.TextSize=16; miniTitle.TextColor3=Color3.fromRGB(255,255,255); miniTitle.Parent=miniFrame
local expandButton = Instance.new("TextButton"); expandButton.Text="+"; expandButton.Size=UDim2.new(0,24,0,24); expandButton.Position=UDim2.new(1,-28,0,4); expandButton.BackgroundColor3=Color3.fromRGB(76,175,80); expandButton.TextColor3=Color3.fromRGB(255,255,255); expandButton.Parent=miniFrame; Instance.new("UICorner", expandButton).CornerRadius=UDim.new(0,5)
enableDrag(miniFrame, miniFrame)

minimizeButton.MouseButton1Click:Connect(function() mainFrame.Visible=false; miniFrame.Visible=true end)
expandButton.MouseButton1Click:Connect(function() miniFrame.Visible=false; mainFrame.Visible=true end)

-- é—œé–‰æŒ‰éˆ•
closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
    for _, v in pairs(connections) do if v then v:Disconnect() end end
    
    -- æ¸…ç†æ‰€æœ‰ ESP
    clearESP("generators")
    clearESP("items")
    
    Lighting.Ambient = trueLightingBackup.Ambient
    Lighting.Brightness = trueLightingBackup.Brightness
    Lighting.OutdoorAmbient = trueLightingBackup.OutdoorAmbient
    Lighting.ColorShift_Top = trueLightingBackup.ColorShift_Top
    Lighting.ColorShift_Bottom = trueLightingBackup.ColorShift_Bottom
    local char = player.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.WalkSpeed = originalSpeed
        end
    end
end)

-- åˆå§‹åŒ–
task.spawn(function()
    if player.Character then task.wait(0.1); getOriginalValues() end
end)

print(update)
print(update2)

-- ====================
-- ShiftLock + ESP UI æ•´åˆ
-- ====================
task.spawn(function()
    pcall(function()
        local ref = cloneref or function(x) return x end
        local S = function(n) return ref(game:GetService(n)) end

        local Plrs, Tw, UIS, RS, Wk, CG =
            S("Players"), S("TweenService"), S("UserInputService"), S("RunService"), S("Workspace"), S("CoreGui")

        local plr = Plrs.LocalPlayer

        local function parentShiftUI(g)
            if gethui then
                g.Name = "\0" .. g.Name
                g.Parent = gethui()
                return g
            elseif CG then
                g.Parent = CG
                return g
            else
                g.Parent = plr:WaitForChild("PlayerGui")
                return g
            end
        end

        local function getParts()
            local c = plr.Character or plr.CharacterAdded:Wait()
            local hum = c:FindFirstChildOfClass("Humanoid") or c:WaitForChild("Humanoid")
            local hrp = c:FindFirstChild("HumanoidRootPart") or c:WaitForChild("HumanoidRootPart")
            return c, hum, hrp
        end

        shiftLockUI = Instance.new("ScreenGui")
        shiftLockUI.Name = "ShiftLockUI"
        shiftLockUI.ResetOnSpawn = false
        shiftLockUI.IgnoreGuiInset = true
        parentShiftUI(shiftLockUI)

        -- ä¸»æŒ‰éˆ•
        local btn = Instance.new("ImageButton")
        btn.Name = "LockBtn"; btn.AnchorPoint = Vector2.new(0.5, 0.5); btn.Size = UDim2.fromOffset(64, 64)
        btn.Position = UDim2.new(1, -30, 1, -30); btn.BackgroundColor3 = Color3.fromRGB(34, 34, 38)
        btn.AutoButtonColor = false; btn.Parent = shiftLockUI
        local cr = Instance.new("UICorner"); cr.CornerRadius = UDim.new(1, 0); cr.Parent = btn
        local strk = Instance.new("UIStroke"); strk.Thickness = 2; strk.Color = Color3.fromRGB(0, 140, 255); strk.Parent = btn
        local icn = Instance.new("ImageLabel")
        icn.Name = "Icn"; icn.BackgroundTransparency = 1; icn.AnchorPoint = Vector2.new(0.5, 0.5)
        icn.Position = UDim2.fromScale(0.5, 0.5); icn.Size = UDim2.fromScale(0.62, 0.62)
        icn.Image = "rbxasset://textures/ui/mouseLock_off.png"; icn.Parent = btn

        -- å°ˆç”¨æ‹–æ›³æŠŠæ‰‹
        local dragHandle = Instance.new("Frame")
        dragHandle.Name = "DragHandle"
        dragHandle.AnchorPoint = Vector2.new(0.5, 1)
        dragHandle.Position = UDim2.new(0.5, 0, 0, -2)
        dragHandle.Size = UDim2.fromOffset(40, 6)
        dragHandle.BackgroundColor3 = Color3.fromRGB(100, 100, 110)
        dragHandle.BorderSizePixel = 0
        dragHandle.Parent = btn
        
        local handleCorner = Instance.new("UICorner")
        handleCorner.CornerRadius = UDim.new(1, 0)
        handleCorner.Parent = dragHandle
        
        -- æ‹–æ›³æŠŠæ‰‹çš„è¦–è¦ºæç¤ºï¼ˆ3å€‹å°é»ï¼‰
        local dot1 = Instance.new("Frame")
        dot1.Size = UDim2.fromOffset(2, 2)
        dot1.Position = UDim2.new(0.3, 0, 0.5, -1)
        dot1.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
        dot1.BorderSizePixel = 0
        dot1.Parent = dragHandle
        Instance.new("UICorner", dot1).CornerRadius = UDim.new(1, 0)
        
        local dot2 = dot1:Clone()
        dot2.Position = UDim2.new(0.5, 0, 0.5, -1)
        dot2.Parent = dragHandle
        
        local dot3 = dot1:Clone()
        dot3.Position = UDim2.new(0.7, 0, 0.5, -1)
        dot3.Parent = dragHandle

        -- é—œé–‰æŒ‰éˆ•
        local xBtn = Instance.new("TextButton")
        xBtn.Name = "Close"; xBtn.AnchorPoint = Vector2.new(1, 0); xBtn.Position = UDim2.new(1, 5, 0, -5)
        xBtn.Size = UDim2.fromOffset(18, 18); xBtn.BackgroundColor3 = Color3.fromRGB(230, 60, 60); xBtn.Text = "Ã—"
        xBtn.TextSize = 14; xBtn.TextColor3 = Color3.new(1, 1, 1); xBtn.Parent = btn
        Instance.new("UICorner").Parent = xBtn

        -- å»¶ä¼¸æŒ‰éˆ•ï¼ˆä½†æš«æ™‚ä¸å‰µå»ºå»¶ä¼¸é¢æ¿ï¼Œå› ç‚ºç¾åœ¨åªæœ‰ ESP åŠŸèƒ½ï¼‰
        local extBtn = Instance.new("TextButton")
        extBtn.Name = "ExtendBtn"; extBtn.AnchorPoint = Vector2.new(0.5, 1); extBtn.Position = UDim2.new(0.5, 0, 0, -15)
        extBtn.Size = UDim2.fromOffset(56, 22); extBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        extBtn.Text = "ESP"; extBtn.TextSize = 12
        extBtn.TextColor3 = Color3.new(1, 1, 1)
        extBtn.Parent = btn
        Instance.new("UICorner").Parent = extBtn

        -- ESP ç›¸é—œ
        local espEnabled = false
        local espLabels = {}
        local espBoxes = {}
        local espConn = nil

        local function cleanupESP(p)
            if espLabels[p] then
                if espLabels[p].billboard then espLabels[p].billboard:Destroy() end
                espLabels[p] = nil
            end
            if espBoxes[p] then
                espBoxes[p]:Destroy()
                espBoxes[p] = nil
            end
        end

        local function createESPBox(character)
            local box = Instance.new("BoxHandleAdornment")
            box.Name = "ESPBox"; box.AlwaysOnTop = true; box.ZIndex = 1
            box.Transparency = 0.7; box.Color3 = Color3.new(1, 1, 1); box.Parent = shiftLockUI
            return box
        end

        local function toggleESP()
            espEnabled = not espEnabled
            
            if not espEnabled then
                if espConn then espConn:Disconnect(); espConn = nil end
                for p, _ in pairs(espLabels) do cleanupESP(p) end
                for p, _ in pairs(espBoxes) do cleanupESP(p) end
            else
                espConn = RS.RenderStepped:Connect(function()
                    local _, _, myHRP = getParts()
                    for _, p in ipairs(Plrs:GetPlayers()) do
                        if p ~= plr then
                            local char = p.Character
                            local hrp = char and char:FindFirstChild("HumanoidRootPart")
                            local hum = char and char:FindFirstChildOfClass("Humanoid")
                            if char and hrp and hum and hum.Health > 0 then
                                if not espLabels[p] then
                                    local bg = Instance.new("BillboardGui")
                                    bg.Size = UDim2.fromOffset(200, 50); bg.AlwaysOnTop = true
                                    bg.StudsOffset = Vector3.new(0, 3, 0); bg.Parent = shiftLockUI
                                    local tl = Instance.new("TextLabel")
                                    tl.Size = UDim2.fromScale(1, 1); tl.BackgroundTransparency = 1
                                    tl.TextColor3 = Color3.new(1, 1, 1); tl.TextStrokeTransparency = 0.5
                                    tl.TextSize = 14; tl.Font = Enum.Font.SourceSansBold; tl.Parent = bg
                                    espLabels[p] = {billboard = bg, label = tl}
                                end
                                if not espBoxes[p] then espBoxes[p] = createESPBox(char) end
                                local dist = myHRP and (myHRP.Position - hrp.Position).Magnitude or 0
                                local lab = espLabels[p]
                                lab.billboard.Adornee = hrp
                                lab.label.Text = string.format("å: %s\nè¡€é‡: %.0f\nè·é›¢: %.1f", p.Name, hum.Health, dist)
                                local box = espBoxes[p]; box.Adornee = char; box.Size = char:GetExtentsSize()
                            else cleanupESP(p) end
                        end
                    end
                    for p, _ in pairs(espLabels) do if not Plrs:FindFirstChild(p.Name) then cleanupESP(p) end end
                end)
            end
        end

        -- ESP æŒ‰éˆ•é»æ“Šï¼ˆä½¿ç”¨ extBtn ä½œç‚º ESP åˆ‡æ›ï¼‰
        extBtn.Activated:Connect(function()
            toggleESP()
            extBtn.Text = espEnabled and "ESP âœ“" or "ESP"
            extBtn.BackgroundColor3 = espEnabled and Color3.fromRGB(76, 175, 80) or Color3.fromRGB(45, 45, 50)
        end)

        -- ShiftLock æŒ‰éˆ•é»æ“Š
        btn.Activated:Connect(function()
            if shiftLockEnabled then
                disableShiftLock()
                icn.Image = "rbxasset://textures/ui/mouseLock_off.png"
                Tw:Create(btn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(34, 34, 38)}):Play()
            else
                enableShiftLock()
                icn.Image = "rbxasset://textures/ui/mouseLock_on.png"
                Tw:Create(btn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(38, 48, 60)}):Play()
            end
        end)

        -- æ‹–æ›³åŠŸèƒ½ï¼ˆä½¿ç”¨æ‹–æ›³æŠŠæ‰‹ï¼‰
        local dragging, dragInput, dragStart, startPos
        
        dragHandle.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = btn.Position
                
                Tw:Create(dragHandle, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(150, 150, 160)}):Play()
                
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                        Tw:Create(dragHandle, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(100, 100, 110)}):Play()
                    end
                end)
            end
        end)
        
        UIS.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - dragStart
                btn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)

        -- é—œé–‰æŒ‰éˆ•
        xBtn.Activated:Connect(function()
            disableShiftLock()
            if espConn then espConn:Disconnect() end
            for p, _ in pairs(espLabels) do cleanupESP(p) end
            for p, _ in pairs(espBoxes) do cleanupESP(p) end
            shiftLockUI:Destroy()
            print("âŒ ShiftLock + ESP ç³»çµ±å·²é—œé–‰")
        end)

        -- é è¨­å•Ÿå‹• ESP
        task.wait(0.5)
        toggleESP()
        extBtn.Text = "ESP âœ“"
        extBtn.BackgroundColor3 = Color3.fromRGB(76, 175, 80)

        print("âœ… ShiftLock + ESP ç³»çµ±å·²æ•´åˆï¼ˆé è¨­å•Ÿå‹• ESPï¼‰")
    end)
end)
